// -*- C++ -*-
//===-------------------------- iterator ----------------------------------===//
//
//                     The LLVM Compiler Infrastructure
//
// This file is dual licensed under the MIT and the University of Illinois Open
// Source Licenses. See LICENSE.TXT for details.
//
//===----------------------------------------------------------------------===//

#pragma once

#ifndef _LIBCPP_INLINE_VISIBILITY
#define _LIBCPP_INLINE_VISIBILITY __attribute__ ((__always_inline__))
#endif
#ifndef _LIBCPP_VISIBLE
#define _LIBCPP_VISIBLE __attribute__ ((__visibility__("default")))
#endif

namespace mpc {
    struct _LIBCPP_VISIBLE input_iterator_tag {};
    struct _LIBCPP_VISIBLE output_iterator_tag {};
    struct _LIBCPP_VISIBLE forward_iterator_tag       : public input_iterator_tag {};
    struct _LIBCPP_VISIBLE bidirectional_iterator_tag : public forward_iterator_tag {};
    struct _LIBCPP_VISIBLE random_access_iterator_tag : public bidirectional_iterator_tag {};

    template <class _Tp>
        struct __has_iterator_category
    {
    private:
        struct __two {char _; char __;};
        template <class _Up> static __two __test(...);
        template <class _Up> static char __test(typename _Up::iterator_category* = 0);
    public:
        static const bool value = sizeof(__test<_Tp>(0)) == 1;
    };

    template <class _Iter, bool> struct ____iterator_traits {};

    template <class _Iter>
        struct ____iterator_traits<_Iter, true>
    {
        typedef typename _Iter::difference_type   difference_type;
        typedef typename _Iter::value_type        value_type;
        typedef typename _Iter::pointer           pointer;
        typedef typename _Iter::reference         reference;
        typedef typename _Iter::iterator_category iterator_category;
    };

    template <class _Iter, bool> struct __iterator_traits {};

    template <class _Iter>
        struct __iterator_traits<_Iter, true>
        :  ____iterator_traits
        <
            _Iter,
            is_convertible<typename _Iter::iterator_category, input_iterator_tag>::value ||
            is_convertible<typename _Iter::iterator_category, output_iterator_tag>::value
            >
    {};

// iterator_traits<Iterator> will only have the nested types if Iterator::iterator_category
//    exists.  Else iterator_traits<Iterator> will be an empty class.  This is a
//    conforming extension which allows some programs to compile and behave as
//    the client expects instead of failing at compile time.

    template <class _Iter>
        struct _LIBCPP_VISIBLE iterator_traits
        : __iterator_traits<_Iter, __has_iterator_category<_Iter>::value> {};

    template<class _Tp>
        struct _LIBCPP_VISIBLE iterator_traits<_Tp*>
    {
        typedef ptrdiff_t difference_type;
        typedef typename remove_const<_Tp>::type value_type;
        typedef _Tp* pointer;
        typedef _Tp& reference;
        typedef random_access_iterator_tag iterator_category;
    };

    template <class _Tp, class _Up, bool = __has_iterator_category<iterator_traits<_Tp> >::value>
        struct __has_iterator_category_convertible_to
            : public integral_constant<bool, is_convertible<typename iterator_traits<_Tp>::iterator_category, _Up>::value>
    {};

    template <class _Tp, class _Up>
        struct __has_iterator_category_convertible_to<_Tp, _Up, false> : public false_type {};

    template <class _Tp>
        struct __is_input_iterator : public __has_iterator_category_convertible_to<_Tp, input_iterator_tag> {};

    template <class _Tp>
        struct __is_forward_iterator : public __has_iterator_category_convertible_to<_Tp, forward_iterator_tag> {};

    template <class _Tp>
        struct __is_bidirectional_iterator : public __has_iterator_category_convertible_to<_Tp, bidirectional_iterator_tag> {};

    template <class _Tp>
        struct __is_random_access_iterator : public __has_iterator_category_convertible_to<_Tp, random_access_iterator_tag> {};

    

};
