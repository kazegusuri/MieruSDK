// -*- C++ -*-
//===-------------------------- iterator ----------------------------------===//
//
//                     The LLVM Compiler Infrastructure
//
// This file is dual licensed under the MIT and the University of Illinois Open
// Source Licenses. See LICENSE.TXT for details.
//
//===----------------------------------------------------------------------===//

#pragma once

#include "iterator_traits"

#ifndef _LIBCPP_INLINE_VISIBILITY
#define _LIBCPP_INLINE_VISIBILITY __attribute__ ((__always_inline__))
#endif
#ifndef _LIBCPP_VISIBLE
#define _LIBCPP_VISIBLE __attribute__ ((__visibility__("default")))
#endif

namespace mpc {

    template <class _Iter>
    class _LIBCPP_VISIBLE reverse_iterator
        : public iterator<typename iterator_traits<_Iter>::iterator_category,
                          typename iterator_traits<_Iter>::value_type,
                          typename iterator_traits<_Iter>::difference_type,
                          typename iterator_traits<_Iter>::pointer,
                          typename iterator_traits<_Iter>::reference>
    {
    private:
        mutable _Iter __t;
    protected:
        _Iter current;
    public:
        typedef _Iter                                            iterator_type;
        typedef typename iterator_traits<_Iter>::difference_type difference_type;
        typedef typename iterator_traits<_Iter>::reference       reference;
        typedef typename iterator_traits<_Iter>::pointer         pointer;

        _LIBCPP_INLINE_VISIBILITY reverse_iterator() : current() {}
        _LIBCPP_INLINE_VISIBILITY explicit reverse_iterator(_Iter __x) : __t(__x), current(__x) {}
        template <class _Up> _LIBCPP_INLINE_VISIBILITY reverse_iterator(const reverse_iterator<_Up>& __u)
            : __t(__u.base()), current(__u.base()) {}
        _LIBCPP_INLINE_VISIBILITY _Iter base() const {return current;}
        _LIBCPP_INLINE_VISIBILITY reference operator*() const {__t = current; return *--__t;}
        _LIBCPP_INLINE_VISIBILITY pointer  operator->() const {return &(operator*());}
        _LIBCPP_INLINE_VISIBILITY reverse_iterator& operator++() {--current; return *this;}
        _LIBCPP_INLINE_VISIBILITY reverse_iterator  operator++(int)
        {reverse_iterator __tmp(*this); --current; return __tmp;}
        _LIBCPP_INLINE_VISIBILITY reverse_iterator& operator--() {++current; return *this;}
        _LIBCPP_INLINE_VISIBILITY reverse_iterator  operator--(int)
        {reverse_iterator __tmp(*this); ++current; return __tmp;}
        _LIBCPP_INLINE_VISIBILITY reverse_iterator  operator+ (difference_type __n) const
        {return reverse_iterator(current - __n);}
        _LIBCPP_INLINE_VISIBILITY reverse_iterator& operator+=(difference_type __n)
        {current -= __n; return *this;}
        _LIBCPP_INLINE_VISIBILITY reverse_iterator  operator- (difference_type __n) const
        {return reverse_iterator(current + __n);}
        _LIBCPP_INLINE_VISIBILITY reverse_iterator& operator-=(difference_type __n)
        {current += __n; return *this;}
        _LIBCPP_INLINE_VISIBILITY reference         operator[](difference_type __n) const
        {return current[-__n-1];}
    };
    
    template <class _Iter1, class _Iter2>
    inline _LIBCPP_INLINE_VISIBILITY
    bool
    operator==(const reverse_iterator<_Iter1>& __x, const reverse_iterator<_Iter2>& __y)
    {
        return __x.base() == __y.base();
    }

    template <class _Iter1, class _Iter2>
    inline _LIBCPP_INLINE_VISIBILITY
    bool
    operator<(const reverse_iterator<_Iter1>& __x, const reverse_iterator<_Iter2>& __y)
    {
        return __x.base() > __y.base();
    }

    template <class _Iter1, class _Iter2>
    inline _LIBCPP_INLINE_VISIBILITY
    bool
    operator!=(const reverse_iterator<_Iter1>& __x, const reverse_iterator<_Iter2>& __y)
    {
        return __x.base() != __y.base();
    }

    template <class _Iter1, class _Iter2>
    inline _LIBCPP_INLINE_VISIBILITY
    bool
    operator>(const reverse_iterator<_Iter1>& __x, const reverse_iterator<_Iter2>& __y)
    {
        return __x.base() < __y.base();
    }

    template <class _Iter1, class _Iter2>
    inline _LIBCPP_INLINE_VISIBILITY
    bool
    operator>=(const reverse_iterator<_Iter1>& __x, const reverse_iterator<_Iter2>& __y)
    {
        return __x.base() <= __y.base();
    }

    template <class _Iter1, class _Iter2>
    inline _LIBCPP_INLINE_VISIBILITY
    bool
    operator<=(const reverse_iterator<_Iter1>& __x, const reverse_iterator<_Iter2>& __y)
    {
        return __x.base() >= __y.base();
    }

    template <class _Iter1, class _Iter2>
    inline _LIBCPP_INLINE_VISIBILITY
    typename reverse_iterator<_Iter1>::difference_type
    operator-(const reverse_iterator<_Iter1>& __x, const reverse_iterator<_Iter2>& __y)
    {
        return __y.base() - __x.base();
    }

    template <class _Iter>
    inline _LIBCPP_INLINE_VISIBILITY
    reverse_iterator<_Iter>
    operator+(typename reverse_iterator<_Iter>::difference_type __n, const reverse_iterator<_Iter>& __x)
    {
        return reverse_iterator<_Iter>(__x.base() - __n);
    }

};
